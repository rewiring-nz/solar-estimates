{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Project Overview","text":"<p>This project will provide accurate and validated estimates of rooftop solar potential for almost every building in New Zealand, for use in tools such as interactive maps.</p> <p>Last updated: Jan 2026</p> <p>View our maps in our webmap browser.</p> <p>This documentation is published at: https://rewiring-nz.github.io/solar-estimates/.</p>"},{"location":"about/","title":"About","text":"<p>This project will provide accurate and validated estimates of rooftop solar potential for almost every building in New Zealand, for use in tools such as interactive maps.</p> <p>Last updated: Jan 2026</p>"},{"location":"about/#features","title":"Features","text":"<ul> <li>Comprehensive: Aims to cover every building in New Zealand, where data is available.  </li> <li>Sophisticated modelling: Will incorporate roof angles, shade profiles, weather patterns, economics.  </li> <li>Useful layers: Potential area and generation estimates can be aggregated by building type, region/local council area, and nationwide.  </li> <li>Free: The data, methodology, software, and any web front-end are shared for free under open licenses.</li> </ul>"},{"location":"about/#project-goals","title":"Project goals","text":"<ul> <li>Empower policymakers, planners, councils, community champions, businesses and households to make evidence based decisions which accelerate the roll out of rooftop solar.  </li> <li>Provide personalised, detailed, and trustworthy evidence of the rooftop solar potential for every rooftop in New Zealand.  </li> <li>Demonstrate that rooftop solar provides the cheapest delivered energy in New Zealand, even with New Zealand\u2019s mountains, low winter sun angles, and shaded valleys.</li> </ul>"},{"location":"contact/","title":"Contributing","text":"<p>Last updated: Jan 2026</p> <p>We are interested to hear from like-minded, tech savvy people tackling similar problems who are interested in collaborating with us.</p> <p>You can see our last task status and priorities in our Kanban board.</p>"},{"location":"contact/#contact","title":"Contact","text":"<p>We communicate and share content via:</p> <ul> <li>Our public solarmap-nz-tech email list.</li> <li>An internal slack chat channel.</li> <li>A weekly meeting.</li> <li>Our solar-estimates github repository.</li> <li>An internally shared Google Drive.</li> </ul> <p>If you\u2019d like to get involved, you can request to join our solarmap-nz-tech email list, or reach out to our project coordinator:</p> <p>Cameron Shorter &lt;cameron DOT shorter AT gmail DOT com&gt;</p>"},{"location":"contact/#time-commitment","title":"Time commitment","text":"<p>Typically, our volunteers contribute ~ 1 to 2 hours per week.</p>"},{"location":"contact/#priorities","title":"Priorities","text":"<p>For volunteers, we expect contributor priorities should be: 1. Family comes first, then 2. Work comes next, then 3. Volunteering.</p> <p>It is okay (and expected) to pause volunteering when higher priorities come up. Just let your coworkers know.</p>"},{"location":"contact/#team","title":"Team","text":""},{"location":"contact/#core-team","title":"Core Team","text":"<ul> <li>Coordinator: Cameron Shorter, Geospatial Analyst, cameron DOT shorter AT gmail DOT com</li> <li>Jenny Sahng, Data Scientist, Rewiring Aotearoa  </li> <li>Shreyas Rama, Geospatial Data Science Masters, University of Canterbury</li> </ul>"},{"location":"contact/#contributors","title":"Contributors","text":"<ul> <li>Rafferty Parker</li> <li>And multiple others (waiting on permission to list here)</li> </ul>"},{"location":"contact/#organisations","title":"Organisations","text":"<p>This project is supported by:</p> <ul> <li>Rewiring Aotearoa</li> <li>The University of Canterbury</li> <li>Anthill Ltd</li> </ul>"},{"location":"downloads/","title":"Downloads","text":"<p>Last updated: Jan 2026</p>"},{"location":"downloads/#webmap","title":"Webmap","text":"<p>View our latest maps in our webmap browser.</p>"},{"location":"downloads/#datasets","title":"Datasets","text":"<p>Our spatial datasets can be downloaded from our Releases directory. These include:</p> <ul> <li>Shotover_country_building_stats-0.0.1.gpkg  </li> <li>Buildings in Shotover County, with annual solar potential  </li> <li>Shotover_country_building_stats-0.0.1.csv  </li> <li>Just the attributes, in CSV format  </li> <li>shotover_country_merged-0.0.1.zip spatial diff and vrt.  </li> <li>1x1 meter grid showing solar potential of each grid</li> </ul> <p>You can download the maps, and then view and analyse from your favourite desktop GIS application. We like the free and powerful QGIS.</p>"},{"location":"downloads/#software","title":"Software","text":"<p>Our latest software can be downloaded from our git repository:</p> <p>https://github.com/rewiring-nz/solar-estimates </p> <p>A tagged software release is on our roadmap.</p>"},{"location":"downloads/#version-history","title":"Version history","text":"Date Version Description 2026-01-30 0.0.1 Proof of concept.Provides map layers for annual solar potential for: 1. Rooftops. 2. 1x1m grid.Considers rooftop slope and direction.Shading calculated from 1x1 grid Digital Surface Model, considers distant mountains and local (trees).Estimates used for other parameters, such as weather.Pipeline script runs in docker.Region limited to a small suburb in Shotover County, New Zealand."},{"location":"downloads/#roadmap","title":"Roadmap","text":"<p>In upcoming releases, we plan to:</p> <ul> <li>Expand our analysis area to all of New Zealand.  </li> <li>Incrementally replace assumptions with deeper analysis, and more data, as listed in tasks in our project kanban board.</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Rewiring Aotearoa</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"quickstart/","title":"Developer Quickstart","text":"<p>This document describes how a developer can get the New Zealand Solar Map tools running in a development environment.</p> <p>Last updated: Jan 2026</p>"},{"location":"quickstart/#context","title":"Context","text":"<p>As at November 2025, these scripts are still a work-in-progress. Reach out to the team for latest advice.</p> <ul> <li>The scripts were initially developed on Mac, as explained in ../src/README.md</li> <li>We now have a version running on Ubuntu 24.04 LTS. Follow install script in ../scripts/setup-ubuntu-nz-solar.sh , then run the python scripts in ../src/README.md</li> </ul>"},{"location":"quickstart/#google-cloud-ubuntu-free-tier-setup","title":"Google Cloud Ubuntu free-tier setup","text":"<p>As at Nov 2025, we haven't got the Cloud Ubuntu environment working. This is as far as we've got so far:</p> <p>This how-to describes setting up a free tier virtual machine (VM) on Google Cloud Platform (GCP) for your NZ Solar Map Tool development.</p>"},{"location":"quickstart/#task-1-create-a-google-cloud-account","title":"Task 1: Create a Google Cloud account","text":"<p>Step 1.1 Create a Google Cloud account with an active project and billing enabled (necessary even for free-tier usage).</p>"},{"location":"quickstart/#task-2-create-a-virtual-machine","title":"Task 2: Create a Virtual Machine","text":"<p>Step 2.1: From the Compute Engine, select \u201cCreate Instance\u201d</p> <p>Step 2.2: Select options:</p> <ol> <li>Region: Iowa, Oregon, or South Carolina   <p>[!WARNING] These are the only free regions. Be careful not to select others.  </p> </li> <li>Machine Type: E2 -&gt; E2-micro.   <p>[!WARNING]  This is the only free machine type.  </p> </li> <li>Operating System: Ubuntu Pro, Ubuntu 24.04 LTS  </li> <li>Disk Size: 30 GB</li> </ol>"},{"location":"quickstart/#task-3-connect-via-ssh","title":"Task 3: Connect via SSH","text":"<p>The easiest way to connect to your new virtual machine is via the browser-based SSH tool provided by GCP.</p> <ol> <li>On the Virtual Machine page, find your new instance.  </li> <li>In the row for your instance, click the SSH button.  </li> <li>A separate browser window will open, automatically establishing a secure connection to your Ubuntu terminal.</li> </ol>"},{"location":"developer/","title":"Developer Guide","text":"<p>This section is designed to help developers of our software.</p> <p>We aim to keep this content concise and timeless, so that it is:</p> <ul> <li>Quick to read.</li> <li>Easy to absorb.</li> <li>Easy to maintain.</li> </ul>"},{"location":"developer/concepts/","title":"Key concepts","text":"<p>This page explains concepts and limitations to understand consider when building solar map layers.</p> <p><pre><code>flowchart\nsubgraph Docker Container\n    direction LR\n    A[Source Datasets] --&gt; C(pipeline.py) --&gt; E[Solar Datasets]\n    B[parameters] --&gt; C\n    D(algorithms) &lt;--&gt; C\nend</code></pre> Diagram: <code>pipeline</code> workflow which generates solar datasets.</p>"},{"location":"developer/concepts/#pipeline-end-to-end-script","title":"Pipeline end-to-end script","text":"<ul> <li>Our main <code>pipeline</code> script provides end-to-end calculations to create solar potential datasets.  </li> <li>The <code>pipeline</code> script is customizable.</li> <li>It accepts parameters to select from datasets, algorithms, and constrained problem spaces.  </li> <li>With each release, we add attributes and improve results, by replacing estimations with better algorithms.</li> </ul>"},{"location":"developer/concepts/#cpu-intensive","title":"CPU intensive","text":"<ul> <li>We process large national datasets, using CPU intensive algorithms, which can take days to months to complete.  </li> <li>So we initially develop and test on small datasets, before scaling to the full problem space.</li> </ul>"},{"location":"developer/concepts/#docker-container","title":"Docker container","text":"<ul> <li>Our command line scripts run inside a Docker container.  </li> <li>This enables our code to be run from multiple platforms, including Mac, Windows, Linux, and to scale to Cloud Computing.  </li> <li>We manage the complicated python and GRASS application dependencies within Docker, building upon UbuntuGIS.</li> </ul>"},{"location":"developer/data/","title":"Key Project Datasets","text":"<p>Primary datasets used in our prject.</p>"},{"location":"developer/data/#new-zealand-lidar-1m-dsm","title":"New Zealand LiDAR 1m DSM","text":"<ul> <li>Description: A high-resolution surface model capturing the elevation of \"first return\" features, including the tops of buildings and tree canopies (920GB).</li> <li>URL: https://data.linz.govt.nz/layer/53621-nz-lidar-1m-dsm-2013-2024/</li> <li>Project Use: Used to calculate specific roof slopes and azimuths, and to model solar shading caused by local vegetation and neighboring structures.</li> <li>Limitations: Very large dataset.</li> </ul>"},{"location":"developer/data/#nz-8m-digital-elevation-model","title":"NZ 8m Digital Elevation Model","text":"<ul> <li>Description: A national-scale elevation model describing the bare ground level, excluding surface objects like trees or buildings (18.84GB).</li> <li>URL: https://data.linz.govt.nz/layer/51768-nz-8m-digital-elevation-model-2012/</li> <li>Project Use: Provides the foundation for low-granularity shading analysis caused by large-scale terrain and mountain ranges.</li> </ul>"},{"location":"developer/data/#nz-building-outlines","title":"NZ Building Outlines","text":"<ul> <li>Description: A dataset containing polygons representing the footprints of buildings across New Zealand (440MB).</li> <li>URL: https://data.linz.govt.nz/layer/101290-nz-building-outlines/</li> <li>Project Use: The primary dataset for identifying individual building locations and footprints for solar potential mapping.</li> <li>Future: Integrate NZ Building Outlines (All Sources) which seems to have more buildings, as well as duplicates.</li> </ul>"},{"location":"developer/data/#meshblock-higher-geographies","title":"Meshblock Higher Geographies","text":"<ul> <li>Description: An administrative dataset that links individual meshblocks to higher-level statistical and local government boundaries (160MB).</li> <li>URL: https://datafinder.stats.govt.nz/layer/123519-meshblock-higher-geographies-2026/</li> <li>Project Use: Used to append administrative attributes to building data, enabling the aggregation of results by region or district.</li> </ul>"},{"location":"developer/data/#reporting-boundaries","title":"Reporting Boundaries","text":"Boundary Title Aggregates MB Meshblock: Street Block (60\u2013120 residents) \u2014 SA1 Statistical Area 1: Neighborhood (100\u2013500 residents) MB SA2 Suburb/Township (1,000\u20134,000 residents) SA1s SA3 Sub-District SA2s TA Territorial Authority: Council/District SA3s REGC Regional Council: Water Catchment Area MB (does not always align with TAs)"},{"location":"developer/design/","title":"Software Architecture and System Design","text":""},{"location":"developer/design/#overview","title":"Overview","text":"<p>The solar-estimates project is a Docker containerised geospatial processing pipeline designed to estimate rooftop solar potential across New Zealand. It leverages GRASS GIS for heavy-duty spatial analysis and GDAL for data translation, all orchestrated by a Python 3.12 <code>pipeline.py</code> application.</p> <p>This content is mostly AI generated from source code (as at Jan 2026).</p> <p>Last updated: Feb 2026</p>"},{"location":"developer/design/#system-workflow","title":"System Workflow","text":"<pre><code>flowchart TD\n\n    %% Stage 1: Input Datasets\n    subgraph Inputs [\"Input Datasets\"]\n        SD1[(DSM GeoTIFF Tiles)]\n        SD2[(Building Outlines)]\n        SD3[(WRF NetCDF - Optional)]\n    end\n\n    %% Stage 2: Interim Datasets\n    subgraph Interim [\"Interim Datasets (Internal GRASS/VRT)\"]\n        ID1[[Merged VRT]]\n        ID2[[GRASS DSM Raster]]\n        ID3[[Slope &amp; Aspect Rasters]]\n        ID4[[Clear-Sky Irradiance]]\n        ID5[[Building Vector Map]]\n        ID6[[Solar on Buildings]]\n        ID7[[Filtered Irradiance]]\n        ID8[[Solar Coefficients]]\n        ID9[[WRF Adjusted Total]]\n    end\n\n    %% Stage 3: Target Datasets\n    subgraph Targets [\"Output Target Datasets\"]\n        TD1[Building Stats GeoPackage]\n        TD2[Building Stats CSV]\n        TD3[Multi-band GeoTIFF]\n    end\n\n    %% Data Flow and Transformation Labels\n    SD1 -- \"merge_rasters\" --&gt; ID1\n    ID1 -- \"load_virtual_raster_into_grass\" --&gt; ID2\n    ID2 -- \"calculate_slope_aspect_rasters\" --&gt; ID3\n    ID2 &amp; ID3 -- \"calculate_solar_irradiance_interpolated\" --&gt; ID4\n    SD2 -- \"load_building_outlines\" --&gt; ID5\n    ID4 &amp; ID5 -- \"calculate_outline_raster\" --&gt; ID6\n    ID6 &amp; ID3 -- \"filter_raster_by_slope\" --&gt; ID7\n\n    %% Optional WRF Path\n    SD3 -- \"process_wrf_for_grass\" --&gt; ID8\n    ID4 -- \"calculate_solar_coefficients\" --&gt; ID8\n    ID8 -- \"calculate_wrf_adjusted_per_day\" --&gt; ID9\n\n    %% Final Exports\n    ID7 &amp; ID9 &amp; ID5 -- \"create_stats\" --&gt; TD1\n    ID7 &amp; ID9 &amp; ID5 -- \"create_stats\" --&gt; TD2\n    ID7 &amp; ID3 -- \"export_final_raster\" --&gt; TD3</code></pre>"},{"location":"developer/design/#technology-stack","title":"Technology Stack","text":""},{"location":"developer/design/#containerisation","title":"Containerisation","text":"<p>The system is built on Docker and Docker Compose to ensure a consistent environment across different platforms (Linux, macOS, Windows).</p> <ul> <li>Base Image: Ubuntu 24.04 LTS (Noble).</li> <li>Geospatial Libraries: Uses the UbuntuGIS Unstable PPA to provide the latest versions of GRASS GIS (8.4+) and GDAL.</li> <li>Python Environment: Dependencies are managed within a virtual environment (<code>/opt/venv</code>) to avoid conflicts with system-level packages.</li> </ul>"},{"location":"developer/design/#computational-engines","title":"Computational Engines","text":"<ul> <li>GRASS GIS: Acts as the primary spatial database and computational engine. It handles solar radiation modelling (<code>r.sun</code>), geometric calculations (<code>r.slope.aspect</code>), and statistical aggregation.</li> <li>GDAL: Used for initial data discovery, building Virtual Rasters (VRT), and final data format exports.</li> </ul>"},{"location":"developer/design/#target-architecture","title":"Target architecture","text":"<p>The following diagram shows the future architecture we are working toward.</p> <p><pre><code>flowchart TD\n\n    %% Style for Future items (traffic-light amber)\n    classDef future fill:#FFE0B2,stroke:#FB8C00,stroke-width:1px,color:#000;\n\n    subgraph A [\"**Sources**\"]\n\n        subgraph AA [\"**Spatial Datasets**\"]\n            direction LR\n            AA1[1m Digital Surface Models]\n            AA2[National building footprints]\n        end\n\n        subgraph AB [\"**Other Datasets**\"]\n            direction LR\n            AB1[Weather: MetService hindcasts]\n            AB2[Energy price - Future]\n            AB3[**Reference Installs**]\n        end\n\n        subgraph AC [\"**Open Source Software**\"]\n            direction LR\n            AC1[Python scripts]\n            AC2[GRASS spatial algorithms]\n            AC3[Docker containers]\n        end\n\n        %% Layout\n        AA ~~~ AB ~~~ AC\n    end\n\n    subgraph B [\"**Analysis**\"]\n        subgraph BA [\"**Spatial Processing**\"]\n            direction LR\n            BA1(Roof slope / aspect)\n            BA2(Shade - Distant mountains / Local Veg)\n            BA3(Roof segment / Solar panel fit - Future)\n            BA4(Time-of-day / Time-of-year)\n            BA5(Aggregation: Region / National - Future)\n        end\n\n        subgraph BB [\"**Weather Analysis**\"]\n            direction LR\n            BB1(Cloudy weather probability - Future)\n            BB2(Scenarios - cold winter week - Future)\n        end\n\n        subgraph BC [\"**Temporal Energy (Future)**\"]\n            direction LR\n            BC1(Spot Energy Price - Future)\n            BC2(Household/Network Load - Future)\n            BC3(Load-shift - Future)\n            BC4(Battery optimization - Future)\n        end\n\n        %% Layout\n        BA ~~~ BB ~~~ BC\n    end\n\n    subgraph C [\"**Validation**\"]\n        direction LR\n        CA1(Against real installations - Future)\n    end\n\n    subgraph D [\"**Dissemination**\"]\n        direction LR\n\n        subgraph DA [\"**Reports**\"]\n            direction LR\n            DA1[Solar energy potential]\n            DA2[Financial viability - Future]\n            DA3[Temporal resilience - Future]\n            DA4[Network resilience - Future]\n            DA5[Scale: Building, Region, Nation]\n        end\n\n        subgraph DB [\"**Downloads**\"]\n            direction LR\n            DB1[Interactive Web Map]\n            DB2[Data and Map Downloads]\n            DB3[Open-Source Code]\n        end\n\n        %% Layout\n        DA ~~~ DB\n    end\n\n    %% Sequential Flow\n    A --&gt; B --&gt; C --&gt; D\n\n    %% Apply Future styling\n    class AB2,BA3,BA5,BB1,BB2,BC1,BC2,BC3,BC4,CA1,DA2,DA3,DA4 future</code></pre> Diagram: Target high level architecture. Boxes tagged with \"Future\" are planned for a future implementation.</p>"},{"location":"developer/github-contribution-guide/","title":"Github Contribution Guide","text":"<p>This guide outlines our github contribution process for our NZ Solar Map project.</p>"},{"location":"developer/github-contribution-guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>Familiarity with the command line and git.</li> <li>You've cloned our git repository.</li> </ul>"},{"location":"developer/github-contribution-guide/#workflow","title":"Workflow","text":"<pre><code>graph TD\n    subgraph \"GitHub (Remote)\"\n        GMain[(Repoository)]\n        subgraph \"GitHub Web UI\"\n            GFeature(Remote Branch)\n            PR[Review &amp; CI Checks]\n            Merge[Merge]\n        end\n    end\n\n    subgraph \"Local Computer\"\n        LMain(Local Sync)\n        LFeature(Working Branch)\n        Test[Develop &amp; Test]\n    end\n\n    %% Workflow\n    GMain -- \"git pull main\" --&gt; LMain\n    LMain -- \"git checkout -b feature\" --&gt; LFeature\n    LFeature --&gt; Test\n    Test --&gt; LFeature\n    LFeature -- \"git push feature\" --&gt; GFeature\n\n    GFeature --&gt; PR\n    PR -- \"Approval\" --&gt; Merge\n    Merge --&gt; GMain</code></pre>"},{"location":"developer/github-contribution-guide/#summary-of-steps","title":"Summary of Steps","text":"<ul> <li>Branch Strategy:<ul> <li>Develop in git branches. Don't git push to <code>main</code>.</li> <li><code>git pull origin main</code> before you start.</li> <li>Push your branch to GitHub.</li> </ul> </li> <li>GitHub Web UI:<ul> <li>Open Pull Request on GitHub.</li> <li>Wait for Automated Tests - Green Check.</li> <li>Request review.<ul> <li>Note: For low-impact documentation changes, you may proceed without a review.</li> </ul> </li> <li>Merge.</li> </ul> </li> </ul>"},{"location":"developer/github-contribution-guide/#location-of-settings","title":"Location of Settings","text":"<p>Rules for our workflow are found in :</p> <ul> <li>Branch Protection Rules: <code>Settings</code> &gt; <code>Branches</code> &gt; <code>Branch protection rules</code>.</li> <li>Actions &amp; CI/CD Settings: <code>Settings</code> &gt; <code>Actions</code> &gt; <code>General</code>.</li> <li>Collaborators &amp; Teams: <code>Settings</code> &gt; <code>Collaborators and teams</code>.</li> </ul> <p>Admin Access Required</p> <p>Only users with Admin permissions can see the <code>Settings</code> tab. If you cannot see it, contact the repository owner to update your permission level.</p>"},{"location":"developer/reference/","title":"Reference Manual","text":""},{"location":"developer/reference/#main-pipeline","title":"Main Pipeline","text":"<p>CLI tool for estimating solar irradiance on buildings from digital surface models.</p>"},{"location":"developer/reference/#pipeline.detect_grass_base","title":"<code>detect_grass_base()</code>","text":"<p>Auto-detect GRASS GIS installation path based on operating system.</p> Source code in <code>src/pipeline.py</code> <pre><code>def detect_grass_base():\n    \"\"\"Auto-detect GRASS GIS installation path based on operating system.\"\"\"\n    if platform.system() == \"Darwin\":\n        return \"/Applications/GRASS-8.4.app/Contents/Resources\"\n    elif platform.system() == \"Linux\":\n        return \"/usr/lib/grass84\"\n    else:\n        return None\n</code></pre>"},{"location":"developer/reference/#utility-modules","title":"Utility Modules","text":""},{"location":"developer/reference/#building-outlines","title":"Building Outlines","text":"<p>Building outlines utilities for GRASS GIS.</p> <p>This module contains helper functions to import building footprint vectors into a GRASS mapset, apply building masks so raster operations affect only building areas, extract masked raster values into building-specific rasters, and export final multi-band GeoTIFFs that include computed rasters (for example, solar irradiance) together with slope and aspect bands.</p>"},{"location":"developer/reference/#utils.building_outlines.apply_building_mask","title":"<code>apply_building_mask(building_vector, grass_module)</code>","text":"<p>Apply a raster mask based on building outlines.</p> <p>The mask created by <code>r.mask</code> restricts subsequent raster operations to the area covered by the given vector. Typical workflows call this beforehand to copy or compute values only for buildings.</p> <p>Parameters:</p> Name Type Description Default <code>building_vector</code> <code>str</code> <p>Name of the building footprint vector in GRASS.</p> required <code>output_name</code> <p>Friendly name returned by the function (no effect on mask).</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/utils/building_outlines.py</code> <pre><code>def apply_building_mask(building_vector: str, grass_module: Any) -&gt; None:\n    \"\"\"Apply a raster mask based on building outlines.\n\n    The mask created by `r.mask` restricts subsequent raster operations to the\n    area covered by the given vector. Typical workflows call this beforehand to copy\n    or compute values only for buildings.\n\n    Args:\n        building_vector: Name of the building footprint vector in GRASS.\n        output_name: Friendly name returned by the function (no effect on mask).\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        None\n    \"\"\"\n    # Create a raster mask from the vector; overwrite any existing mask\n    r_mask = grass_module(\"r.mask\", vector=building_vector, overwrite=True)\n    r_mask.run()\n</code></pre>"},{"location":"developer/reference/#utils.building_outlines.calculate_outline_raster","title":"<code>calculate_outline_raster(solar_irradiance_raster, building_vector, output_name, grass_module)</code>","text":"<p>Create a raster containing values only for building outlines.</p> <p>Parameters:</p> Name Type Description Default <code>solar_irradiance_raster</code> <code>str</code> <p>Name of the solar irradiance raster to be masked.</p> required <code>building_vector</code> <code>str</code> <p>Name of the building footprint vector to use for masking.</p> required <code>output_name</code> <code>str</code> <p>Name to assign to the resulting building-only raster.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The GRASS raster name.</p> Source code in <code>src/utils/building_outlines.py</code> <pre><code>def calculate_outline_raster(\n    solar_irradiance_raster: str,\n    building_vector: str,\n    output_name: str,\n    grass_module: Any,\n) -&gt; str:\n    \"\"\"Create a raster containing values only for building outlines.\n\n    Args:\n        solar_irradiance_raster: Name of the solar irradiance raster to be masked.\n        building_vector: Name of the building footprint vector to use for masking.\n        output_name: Name to assign to the resulting building-only raster.\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        The GRASS raster name.\n    \"\"\"\n    # Apply mask using the building vector\n    apply_building_mask(building_vector, grass_module=grass_module)\n\n    # Copy values from the source raster into the masked output raster\n    r_mapcalc = grass_module(\n        \"r.mapcalc\",\n        expression=f\"{output_name} = {solar_irradiance_raster}\",\n        overwrite=True,\n    )\n    r_mapcalc.run()\n\n    return output_name\n</code></pre>"},{"location":"developer/reference/#utils.building_outlines.export_final_raster","title":"<code>export_final_raster(raster_name, slope, aspect, output_tif, grass_module)</code>","text":"<p>Export a multi-band GeoTIFF containing raster, slope, and aspect.</p> This function <ul> <li>Creates an imagery group containing the three rasters using <code>i.group</code>.</li> <li>Calls <code>r.out.gdal</code> to export the group as a multi-band GeoTIFF.</li> <li>Removes the temporary imagery group.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>raster_name</code> <code>str</code> <p>Name of the primary raster to export (e.g., building-only GHI).</p> required <code>slope</code> <code>str</code> <p>Name of the slope raster to include as a band.</p> required <code>aspect</code> <code>str</code> <p>Name of the aspect raster to include as a band.</p> required <code>output_tif</code> <code>str</code> <p>Path for the output GeoTIFF file to create.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The <code>output_tif</code> path for convenience.</p> Source code in <code>src/utils/building_outlines.py</code> <pre><code>def export_final_raster(\n    raster_name: str,\n    slope: str,\n    aspect: str,\n    output_tif: str,\n    grass_module: Any,\n) -&gt; str:\n    \"\"\"Export a multi-band GeoTIFF containing raster, slope, and aspect.\n\n    This function:\n      - Creates an imagery group containing the three rasters using `i.group`.\n      - Calls `r.out.gdal` to export the group as a multi-band GeoTIFF.\n      - Removes the temporary imagery group.\n\n    Args:\n        raster_name: Name of the primary raster to export (e.g., building-only GHI).\n        slope: Name of the slope raster to include as a band.\n        aspect: Name of the aspect raster to include as a band.\n        output_tif: Path for the output GeoTIFF file to create.\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        The `output_tif` path for convenience.\n    \"\"\"\n    # Create a temporary imagery group containing the three rasters. This groups\n    # the rasters into a single multi-band dataset.\n    group_name = f\"{raster_name}_group\"\n    i_group = grass_module(\n        \"i.group\",\n        group=group_name,\n        input=f\"{raster_name},{slope},{aspect}\",\n    )\n    i_group.run()\n\n    # TFW = World File containing georeferencing info\n    # LZW = Lempel-Ziv-Welch lossless compression algorithm\n    r_out_multiband = grass_module(\n        \"r.out.gdal\",\n        input=group_name,\n        output=output_tif,\n        format=\"GTiff\",\n        createopt=\"TFW=YES,COMPRESS=LZW\",\n        overwrite=True,\n    )\n    r_out_multiband.run()\n\n    # Clean up the temporary group to avoid leaving workspace state behind.\n    g_remove = grass_module(\n        \"g.remove\",\n        type=\"group\",\n        name=group_name,\n        flags=\"f\",  # force removal without extra prompts\n    )\n    g_remove.run()\n\n    return output_tif\n</code></pre>"},{"location":"developer/reference/#utils.building_outlines.load_building_outlines","title":"<code>load_building_outlines(shapefile, output_name, grass_module)</code>","text":"<p>Import building outlines (vector) from a shapefile into GRASS.</p> <p>This uses the <code>v.in.ogr</code> GRASS module to import a vector dataset from a shapefile into the current GRASS mapset.</p> <p>Parameters:</p> Name Type Description Default <code>shapefile</code> <code>str</code> <p>Path to the directory containing a building footprints shapefile.</p> required <code>output_name</code> <code>str</code> <p>Name to assign to the vector map inside GRASS.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The GRASS vector name.</p> Source code in <code>src/utils/building_outlines.py</code> <pre><code>def load_building_outlines(shapefile: str, output_name: str, grass_module: Any) -&gt; str:\n    \"\"\"Import building outlines (vector) from a shapefile into GRASS.\n\n    This uses the `v.in.ogr` GRASS module to import a vector dataset from a\n    shapefile into the current GRASS mapset.\n\n    Args:\n        shapefile: Path to the directory containing a building footprints shapefile.\n        output_name: Name to assign to the vector map inside GRASS.\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        The GRASS vector name.\n    \"\"\"\n    # Import vector into GRASS; overwrite if a vector with the same name exists\n    v_in = grass_module(\"v.in.ogr\", input=shapefile, output=output_name, overwrite=True)\n    v_in.run()\n\n    return output_name\n</code></pre>"},{"location":"developer/reference/#utils.building_outlines.remove_masks","title":"<code>remove_masks(grass_module)</code>","text":"<p>Remove any active raster mask(s) in the current GRASS session.</p> <p>This helper attempts to reset raster masking by calling <code>r.mask -r</code>.</p> <p>Parameters:</p> Name Type Description Default <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if removing the mask encounters an error.</p> Source code in <code>src/utils/building_outlines.py</code> <pre><code>def remove_masks(grass_module: Any) -&gt; None:\n    \"\"\"Remove any active raster mask(s) in the current GRASS session.\n\n    This helper attempts to reset raster masking by calling `r.mask -r`.\n\n    Args:\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        None\n\n    Raises:\n        Exception: if removing the mask encounters an error.\n    \"\"\"\n    try:\n        # The 'r' flag removes the active mask\n        r_mask = grass_module(\"r.mask\", flags=\"r\")\n        r_mask.run()\n    except Exception as e:  # Don't break the workflow if it can't remove the mask\n        print(f\"\u26a0\ufe0f Warning: error removing GRASS mask: {e}\")\n</code></pre>"},{"location":"developer/reference/#dsm-utilities","title":"DSM Utilities","text":"<p>Digital Surface Model (DSM) utilities.</p> <p>This module contains helper functions for working with DSM rasters, using GDAL and GRASS GIS.</p> <p>High-level responsibilities: - Attaching virtual rasters (VRT) to GRASS as external rasters. - Merging tiled DSM GeoTIFFs into a single VRT (optionally can be translated   to a GeoTIFF). - Calculating slope and aspect rasters from a DSM. - Filtering rasters.</p>"},{"location":"developer/reference/#utils.dsm.calculate_slope_aspect_rasters","title":"<code>calculate_slope_aspect_rasters(dsm, grass_module)</code>","text":"<p>Compute slope and aspect rasters from a DSM using GRASS <code>r.slope.aspect</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dsm</code> <code>str</code> <p>Name of the DSM raster in the GRASS mapset.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>A tuple <code>(aspect_raster_name, slope_raster_name)</code>.</p> Source code in <code>src/utils/dsm.py</code> <pre><code>def calculate_slope_aspect_rasters(dsm: str, grass_module: Any) -&gt; Tuple[str, str]:\n    \"\"\"Compute slope and aspect rasters from a DSM using GRASS `r.slope.aspect`.\n\n    Args:\n        dsm: Name of the DSM raster in the GRASS mapset.\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        A tuple `(aspect_raster_name, slope_raster_name)`.\n    \"\"\"\n    r_slope_aspect = grass_module(\n        \"r.slope.aspect\",\n        elevation=dsm,\n        slope=f\"{dsm}_slope\",\n        aspect=f\"{dsm}_aspect\",\n        format=\"degrees\",\n        precision=\"FCELL\",\n        a=True,  # compute aspect\n        nprocs=16,\n        overwrite=True,\n    )\n    r_slope_aspect.run()\n\n    return f\"{dsm}_aspect\", f\"{dsm}_slope\"\n</code></pre>"},{"location":"developer/reference/#utils.dsm.filter_raster_by_slope","title":"<code>filter_raster_by_slope(input_raster, slope_raster, max_slope_degrees, output_name, grass_module)</code>","text":"<p>Filter <code>input_raster</code> to only keep pixels where slope &lt;= max_slope_degrees.</p> <p>This function uses a <code>r.mapcalc</code> expression to produce a masked raster where any pixel with slope greater than <code>max_slope_degrees</code> is set to NULL (GRASS NULL) and valid pixels retain their original value.</p> Example expression used <p>output = if(slope_raster &lt;= max_slope_degrees, input_raster, null())</p> <p>Parameters:</p> Name Type Description Default <code>input_raster</code> <code>str</code> <p>GRASS raster name containing the values to be filtered.</p> required <code>slope_raster</code> <code>str</code> <p>GRASS raster name containing slope in degrees.</p> required <code>max_slope_degrees</code> <code>float</code> <p>Maximum allowed slope (inclusive). Pixels with slope greater than this value will be masked to NULL.</p> required <code>output_name</code> <code>str</code> <p>Name for the output raster.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the output raster.</p> Source code in <code>src/utils/dsm.py</code> <pre><code>def filter_raster_by_slope(\n    input_raster: str,\n    slope_raster: str,\n    max_slope_degrees: float,\n    output_name: str,\n    grass_module: Any,\n) -&gt; str:\n    \"\"\"Filter `input_raster` to only keep pixels where slope &lt;= max_slope_degrees.\n\n    This function uses a `r.mapcalc` expression to produce a masked\n    raster where any pixel with slope greater than `max_slope_degrees` is set\n    to NULL (GRASS NULL) and valid pixels retain their original value.\n\n    Example expression used:\n        output = if(slope_raster &lt;= max_slope_degrees, input_raster, null())\n\n    Args:\n        input_raster: GRASS raster name containing the values to be filtered.\n        slope_raster: GRASS raster name containing slope in degrees.\n        max_slope_degrees: Maximum allowed slope (inclusive). Pixels with slope\n            greater than this value will be masked to NULL.\n        output_name: Name for the output raster.\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        The name of the output raster.\n    \"\"\"\n    # Build and run the r.mapcalc expression to mask out steep slopes\n    expression = (\n        f\"{output_name} = if({slope_raster} &lt;= {max_slope_degrees}, \"\n        f\"{input_raster}, null())\"\n    )\n    r_mapcalc = grass_module(\"r.mapcalc\", expression=expression, overwrite=True)\n    r_mapcalc.run()\n\n    return output_name\n</code></pre>"},{"location":"developer/reference/#utils.dsm.load_virtual_raster_into_grass","title":"<code>load_virtual_raster_into_grass(input_vrt, output_name, grass_module)</code>","text":"<p>Attach a VRT (virtual raster) to GRASS using <code>r.external</code> and set region.</p> <p>Using <code>r.external</code> avoids copying data into the GRASS database; the VRT is referenced externally which is faster and uses no additional disk space.</p> <p>Parameters:</p> Name Type Description Default <code>input_vrt</code> <code>str</code> <p>Path to the VRT file on disk.</p> required <code>output_name</code> <code>str</code> <p>The raster name to expose inside GRASS.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The GRASS raster name.</p> Source code in <code>src/utils/dsm.py</code> <pre><code>def load_virtual_raster_into_grass(\n    input_vrt: str, output_name: str, grass_module: Any\n) -&gt; str:\n    \"\"\"Attach a VRT (virtual raster) to GRASS using `r.external` and set region.\n\n    Using `r.external` avoids copying data into the GRASS database; the VRT is\n    referenced externally which is faster and uses no additional disk space.\n\n    Args:\n        input_vrt: Path to the VRT file on disk.\n        output_name: The raster name to expose inside GRASS.\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        The GRASS raster name.\n    \"\"\"\n    # Register the VRT as an external raster\n    r_external = grass_module(\n        \"r.external\", input=input_vrt, output=output_name, band=1, overwrite=True\n    )\n    r_external.run()\n\n    # Print and set the region to match the attached raster\n    g_region = grass_module(\"g.region\", raster=output_name, flags=\"p\")\n    g_region.run()\n\n    return output_name\n</code></pre>"},{"location":"developer/reference/#utils.dsm.merge_rasters","title":"<code>merge_rasters(dsm_file_glob, area_name, output_dir)</code>","text":"<p>Merge tiled DSM files into a single VRT using GDAL.</p> <p>This function discovers DSM tiles using a glob pattern, builds a GDAL VRT (virtual raster) that mosaics them together, and returns the VRT filename. The function intentionally leaves the VRT on disk instead of translating to a final GeoTIFF so callers can decide on translation parameters (compression, data type, nodata handling) or feed the VRT directly to GRASS via <code>r.external</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dsm_file_glob</code> <code>str</code> <p>Glob pattern matching input DSM tiles.</p> required <code>area_name</code> <code>str</code> <p>Prefix to use for the generated VRT filename.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the generated VRT file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the glob pattern matches no files.</p> <code>RuntimeError</code> <p>If GDAL fails to create the VRT for any reason.</p> Source code in <code>src/utils/dsm.py</code> <pre><code>def merge_rasters(dsm_file_glob: str, area_name: str, output_dir: Path) -&gt; str:\n    \"\"\"Merge tiled DSM files into a single VRT using GDAL.\n\n    This function discovers DSM tiles using a glob pattern, builds a GDAL VRT\n    (virtual raster) that mosaics them together, and returns the VRT filename.\n    The function intentionally leaves the VRT on disk instead of translating to\n    a final GeoTIFF so callers can decide on translation parameters (compression,\n    data type, nodata handling) or feed the VRT directly to GRASS via `r.external`.\n\n    Args:\n        dsm_file_glob: Glob pattern matching input DSM tiles.\n        area_name: Prefix to use for the generated VRT filename.\n\n    Returns:\n        The path to the generated VRT file.\n\n    Raises:\n        FileNotFoundError: If the glob pattern matches no files.\n        RuntimeError: If GDAL fails to create the VRT for any reason.\n    \"\"\"\n    # Find input files using the glob pattern\n    dsm_files = glob.glob(dsm_file_glob)\n    if not dsm_files:\n        raise FileNotFoundError(f\"\ud83d\udeab No files found for pattern: {dsm_file_glob}\")\n\n    # Build a Virtual Raster (VRT). Use nearest-neighbor resampling by default\n    try:\n        vrt_options = gdal.BuildVRTOptions(resampleAlg=gdal.GRA_NearestNeighbour)\n        vrt_path = f\"{str(output_dir)}/{area_name}_merged.vrt\"\n        gdal.BuildVRT(vrt_path, dsm_files, options=vrt_options)\n    except Exception as e:\n        # Propagate any errors\n        raise RuntimeError(\n            f\"\ud83d\udeab Failed to build VRT from {len(dsm_files)} files: {e}\"\n        ) from e\n\n    # Return the VRT path\n    return vrt_path\n</code></pre>"},{"location":"developer/reference/#solar-irradiance","title":"Solar Irradiance","text":"<p>Solar irradiance calculation utilities for GRASS GIS.</p> <p>This module provides functions for calculating solar irradiance using the GRASS GIS r.sun module. It supports both single-day calculations and interpolated multi-day calculations for seasonal analysis, as well as creating normalized coefficient rasters for WRF data adjustment.</p> <p>The main workflow (if WRF data is provided) involves:     1. Calculate solar irradiance for key sample days using r.sun     2. Interpolate between key days to generate daily irradiance maps     3. Normalize to create coefficient rasters to adjust WRF data</p>"},{"location":"developer/reference/#utils.solar_irradiance.calculate_solar_coefficients","title":"<code>calculate_solar_coefficients(day_irradiance_rasters, dsm, grass_module)</code>","text":"<p>Calculate normalized solar coefficients for each day's irradiance.</p> <p>Converts irradiance values (Wh/m\u00b2) to relative coefficients (0-1) using min-max normalization.</p> <p>The coefficients are then used to adjust WRF irradiance data so it accounts for roof shape, shading, etc.</p> <p>Parameters:</p> Name Type Description Default <code>day_irradiance_rasters</code> <code>dict[int, str]</code> <p>Dict mapping day-of-year to irradiance raster names, as returned by calculate_solar_irradiance_interpolated().</p> required <code>dsm</code> <code>str</code> <p>Name of the DSM raster, used as a prefix for output names.</p> required <code>grass_module</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>dict[int, str]</code> <p>Dict mapping day-of-year (int) to coefficient raster name (str).</p> Source code in <code>src/utils/solar_irradiance.py</code> <pre><code>def calculate_solar_coefficients(\n    day_irradiance_rasters: dict[int, str],\n    dsm: str,\n    grass_module,\n) -&gt; dict[int, str]:\n    \"\"\"Calculate normalized solar coefficients for each day's irradiance.\n\n    Converts irradiance values (Wh/m\u00b2) to relative coefficients (0-1)\n    using min-max normalization.\n\n    The coefficients are then used to adjust WRF irradiance data so it\n    accounts for roof shape, shading, etc.\n\n    Args:\n        day_irradiance_rasters: Dict mapping day-of-year to irradiance raster\n            names, as returned by calculate_solar_irradiance_interpolated().\n        dsm: Name of the DSM raster, used as a prefix for output names.\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        Dict mapping day-of-year (int) to coefficient raster name (str).\n    \"\"\"\n    day_coefficient_rasters = {}\n\n    for day, irradiance_raster in day_irradiance_rasters.items():\n        coefficient_raster = f\"{dsm}_solar_coefficient_day{day}\"\n        _normalize_raster(irradiance_raster, coefficient_raster, grass_module)\n        day_coefficient_rasters[day] = coefficient_raster\n\n    return day_coefficient_rasters\n</code></pre>"},{"location":"developer/reference/#utils.solar_irradiance.calculate_solar_irradiance","title":"<code>calculate_solar_irradiance(dsm, grass_output, aspect, slope, day, step, grass_module)</code>","text":"<p>Calculate solar irradiance for a single day using the GRASS r.sun module.</p> <p>This function wraps the r.sun solar radiation model to compute global horizontal irradiance (GHI) under clear-sky conditions. The Linke turbidity factor is automatically interpolated based on the day of year.</p> <p>Parameters:</p> Name Type Description Default <code>dsm</code> <code>str</code> <p>Name of the input Digital Surface Model (elevation) raster in GRASS.</p> required <code>grass_output</code> <code>str</code> <p>Name for the output global radiation raster.</p> required <code>aspect</code> <p>Name of the aspect raster (direction of slope) in GRASS.</p> required <code>slope</code> <p>Name of the slope raster (steepness) in GRASS.</p> required <code>day</code> <code>int</code> <p>Day of year (1-365) for the irradiance calculation.</p> required <code>step</code> <code>float</code> <p>Time step in hours for the r.sun calculation. Smaller values (e.g., 0.5) give more accurate results but take longer.</p> required <code>grass_module</code> <p>The GRASS Python scripting Module class for running GRASS commands.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the output global radiation raster (same as grass_output).</p> Note <p>This function assumes the GRASS computational region is already set appropriately for the DSM. The output units are Wh/m\u00b2/day.</p> Source code in <code>src/utils/solar_irradiance.py</code> <pre><code>def calculate_solar_irradiance(\n    dsm: str,\n    grass_output: str,\n    aspect,\n    slope,\n    day: int,\n    step: float,\n    grass_module,\n) -&gt; str:\n    \"\"\"Calculate solar irradiance for a single day using the GRASS r.sun module.\n\n    This function wraps the r.sun solar radiation model to compute global\n    horizontal irradiance (GHI) under clear-sky conditions. The Linke turbidity\n    factor is automatically interpolated based on the day of year.\n\n    Args:\n        dsm: Name of the input Digital Surface Model (elevation) raster in GRASS.\n        grass_output: Name for the output global radiation raster.\n        aspect: Name of the aspect raster (direction of slope) in GRASS.\n        slope: Name of the slope raster (steepness) in GRASS.\n        day: Day of year (1-365) for the irradiance calculation.\n        step: Time step in hours for the r.sun calculation.\n            Smaller values (e.g., 0.5) give more accurate results but take longer.\n        grass_module: The GRASS Python scripting Module class for running\n            GRASS commands.\n\n    Returns:\n        The name of the output global radiation raster (same as grass_output).\n\n    Note:\n        This function assumes the GRASS computational region is already set\n        appropriately for the DSM. The output units are Wh/m\u00b2/day.\n    \"\"\"\n    grass_module(\n        \"r.sun\",\n        elevation=dsm,\n        aspect=aspect,\n        slope=slope,\n        day=day,\n        step=step,\n        linke_value=linke_by_day(day),\n        nprocs=16,\n        glob_rad=grass_output,\n        overwrite=True,\n    ).run()\n\n    return grass_output\n</code></pre>"},{"location":"developer/reference/#utils.solar_irradiance.calculate_solar_irradiance_interpolated","title":"<code>calculate_solar_irradiance_interpolated(dsm, aspect, slope, key_days, step, grass_module, export=False)</code>","text":"<p>Calculate interpolated solar irradiance between key sample days.</p> <p>This function computes solar irradiance for a set of key days, then uses linear interpolation (via r.series.interp) to estimate irradiance for all days in the range.</p> Workflow <ol> <li>Run r.sun for each key day to get irradiance values</li> <li>Interpolate between key days to fill in the intermediate days</li> <li>Sum all daily rasters to get total irradiance over the period</li> </ol> <p>Parameters:</p> Name Type Description Default <code>dsm</code> <code>str</code> <p>Name of the Digital Surface Model raster in GRASS.</p> required <code>aspect</code> <p>Name of the aspect raster in GRASS.</p> required <code>slope</code> <p>Name of the slope raster in GRASS.</p> required <code>key_days</code> <code>list[int]</code> <p>List of day-of-year values (1-365) to estimate irradiance.</p> required <code>step</code> <code>float</code> <p>Time step in hours for the r.sun calculation. Smaller values (e.g., 0.5) give more accurate results but take longer.</p> required <code>grass_module</code> <p>The GRASS Python scripting Module class.</p> required <code>export</code> <code>bool</code> <p>If True, export the summed irradiance raster as a GeoTIFF. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[dict[int, str], str]</code> <p>A tuple containing: - day_irradiance_rasters: Dict mapping day-of-year (int) to the   irradiance raster name (str) for each day in the range from   min(key_days) to max(key_days). This includes both the exact   r.sun calculations for key_days and interpolated values for   days in between. The caller is responsible for cleaning up   these rasters when no longer needed. - summed_irradiance: Name of the raster containing the sum of   all daily irradiance values (total Wh/m\u00b2 over the period).</p> Source code in <code>src/utils/solar_irradiance.py</code> <pre><code>def calculate_solar_irradiance_interpolated(\n    dsm: str,\n    aspect,\n    slope,\n    key_days: list[int],\n    step: float,\n    grass_module,\n    export: bool = False,\n) -&gt; tuple[dict[int, str], str]:\n    \"\"\"Calculate interpolated solar irradiance between key sample days.\n\n    This function computes solar irradiance for a set of key days, then uses\n    linear interpolation (via r.series.interp) to estimate irradiance for all\n    days in the range.\n\n    Workflow:\n        1. Run r.sun for each key day to get irradiance values\n        2. Interpolate between key days to fill in the intermediate days\n        3. Sum all daily rasters to get total irradiance over the period\n\n    Args:\n        dsm: Name of the Digital Surface Model raster in GRASS.\n        aspect: Name of the aspect raster in GRASS.\n        slope: Name of the slope raster in GRASS.\n        key_days: List of day-of-year values (1-365) to estimate irradiance.\n        step: Time step in hours for the r.sun calculation.\n            Smaller values (e.g., 0.5) give more accurate results but take longer.\n        grass_module: The GRASS Python scripting Module class.\n        export: If True, export the summed irradiance raster as a GeoTIFF.\n            Defaults to False.\n\n    Returns:\n        A tuple containing:\n            - day_irradiance_rasters: Dict mapping day-of-year (int) to the\n              irradiance raster name (str) for each day in the range from\n              min(key_days) to max(key_days). This includes both the exact\n              r.sun calculations for key_days and interpolated values for\n              days in between. The caller is responsible for cleaning up\n              these rasters when no longer needed.\n            - summed_irradiance: Name of the raster containing the sum of\n              all daily irradiance values (total Wh/m\u00b2 over the period).\n    \"\"\"\n    # Step 1: Calculate irradiance for each key day\n    key_day_rasters = []\n    for day in key_days:\n        day_map = calculate_solar_irradiance(\n            dsm=dsm,\n            grass_output=f\"{dsm}_solar_irradiance_day{day}\",\n            aspect=aspect,\n            slope=slope,\n            day=day,\n            step=step,\n            grass_module=grass_module,\n        )\n        key_day_rasters.append(day_map)\n\n    # Step 2: Interpolate to days between the key days (excluding key days themselves)\n    all_days = list(range(min(key_days), max(key_days) + 1))\n    key_days_set = set(key_days)\n    interp_only_days = [day for day in all_days if day not in key_days_set]\n\n    # Build the output raster mapping, starting with the key day rasters we already have\n    day_irradiance_rasters = {\n        day: key_day_rasters[i] for i, day in enumerate(key_days)\n    }\n\n    # Only run interpolation if there are days between the key days\n    if interp_only_days:\n        interp_rasters = [\n            f\"{dsm}_solar_irradiance_interp_day{day}\" for day in interp_only_days\n        ]\n\n        # datapos = key_days positions correspond to input rasters\n        # samplingpos = interp_only_days positions for output rasters\n        grass_module(\n            \"r.series.interp\",\n            input=\",\".join(key_day_rasters),\n            datapos=key_days,\n            output=\",\".join(interp_rasters),\n            samplingpos=interp_only_days,\n            method=\"linear\",\n            overwrite=True,\n        ).run()\n\n        # Add interpolated rasters to the mapping\n        for i, day in enumerate(interp_only_days):\n            day_irradiance_rasters[day] = interp_rasters[i]\n\n    # Step 3: Sum all rasters (key days + interpolated) to get total irradiance\n    all_rasters = list(day_irradiance_rasters.values())\n    summed_irradiance = f\"{dsm}_solar_irradiance_interp\"\n    grass_module(\n        \"r.series\",\n        input=\",\".join(all_rasters),\n        output=summed_irradiance,\n        method=\"sum\",\n        overwrite=True,\n    ).run()\n\n    # Optionally export the summed raster as a GeoTIFF\n    if export:\n        grass_module(\n            \"r.out.gdal\",\n            input=summed_irradiance,\n            output=f\"{summed_irradiance}.tif\",\n            format=\"GTiff\",\n            createopt=\"TFW=YES,COMPRESS=LZW\",\n            overwrite=True,\n        ).run()\n\n    return day_irradiance_rasters, summed_irradiance\n</code></pre>"},{"location":"developer/reference/#statistics","title":"Statistics","text":"<p>Statistics helpers for rooftop solar calculations in GRASS GIS.</p> <p>This module provides helpers to compute per-building statistics by sampling rasters (clear-sky irradiance and optional WRF-adjusted irradiance) using GRASS vector/raster database functions. The workflow implemented here is:</p> <ol> <li>Use <code>v.rast.stats</code> to compute aggregated raster statistics (sum, count)    for each building polygon.</li> <li>Create and update attribute columns (kWh, MWh, usable sqm) using    <code>v.db.addcolumn</code> and <code>v.db.update</code>.</li> <li>Optionally compute WRF-derived statistics and a percent loss comparison    between the calculated clear-sky values and WRF measured values.</li> <li>Export results to a GeoPackage and optionally a CSV.</li> </ol>"},{"location":"developer/reference/#utils.stats.create_stats","title":"<code>create_stats(area, building_outlines, output_dir, rooftop_raster, grass_module, wrf_raster=None, output_csv=True)</code>","text":"<p>High-level workflow to produce building-level rooftop irradiance statistics.</p> <p>Parameters:</p> Name Type Description Default <code>area</code> <code>str</code> <p>Descriptive name for the area used as a prefix for output files.</p> required <code>building_outlines</code> <code>str</code> <p>GRASS vector name containing building polygons.</p> required <code>rooftop_raster</code> <code>str</code> <p>GRASS raster name containing rooftop irradiance (Wh).</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <code>wrf_raster</code> <code>Optional[str]</code> <p>Optional GRASS raster name for WRF-adjusted irradiance.</p> <code>None</code> <code>output_csv</code> <code>bool</code> <p>If True, also export a CSV summary. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the generated GeoPackage file containing building statistics.</p> Source code in <code>src/utils/stats.py</code> <pre><code>def create_stats(\n    area: str,\n    building_outlines: str,\n    output_dir: Path,\n    rooftop_raster: str,\n    grass_module: Any,\n    wrf_raster: Optional[str] = None,\n    output_csv: bool = True,\n) -&gt; str:\n    \"\"\"High-level workflow to produce building-level rooftop irradiance statistics.\n\n    Args:\n        area: Descriptive name for the area used as a prefix for output files.\n        building_outlines: GRASS vector name containing building polygons.\n        rooftop_raster: GRASS raster name containing rooftop irradiance (Wh).\n        grass_module: The GRASS Python scripting Module class.\n        wrf_raster: Optional GRASS raster name for WRF-adjusted irradiance.\n        output_csv: If True, also export a CSV summary. Defaults to True.\n\n    Returns:\n        Path to the generated GeoPackage file containing building statistics.\n    \"\"\"\n    # Compute clear-sky (calculated) stats and update vector attributes\n    building_outlines = _calculate_clear_sky_stats(\n        building_outlines, rooftop_raster, grass_module\n    )\n\n    # Optionally compute WRF-derived stats\n    has_wrf = wrf_raster is not None\n    if has_wrf:\n        building_outlines = _calculate_wrf_stats(\n            building_outlines, wrf_raster, grass_module\n        )\n\n    # Export combined stats to GeoPackage and optionally CSV\n    gpkg_file = _export_combined_stats(\n        area, building_outlines, output_dir, output_csv, grass_module, has_wrf=has_wrf\n    )\n\n    return gpkg_file\n</code></pre>"},{"location":"developer/reference/#weather-wrf","title":"Weather (WRF)","text":"<p>WRF (Weather Research and Forecasting) functionality for GRASS GIS workflows.</p> <p>This module contains utilities to load, reproject, clip, import and summarise WRF-derived solar variables (surface downward shortwave radiation).</p> <p>High level responsibilities: - Read WRF NetCDF files via xarray and manage the CRS, including reprojections,   and creating per-day WRF rasters. - Helpers to multiply WRF rasters by normalized coefficient rasters,   sum per-day adjusted rasters, and produce a summed WRF raster for comparison   against clear-sky modeled values.</p>"},{"location":"developer/reference/#utils.wrf.calculate_wrf_adjusted_per_day","title":"<code>calculate_wrf_adjusted_per_day(wrf_day_rasters, coefficient_rasters, grass_module, output_prefix='wrf_adjusted')</code>","text":"<p>Multiply per-day WRF rasters by corresponding coefficient rasters.</p> <p>This creates a new GRASS raster for each day named \"_day{doy}\". <p>Parameters:</p> Name Type Description Default <code>wrf_day_rasters</code> <code>Dict[int, str]</code> <p>Mapping from day-of-year (int) to GRASS raster name containing that day's WRF data.</p> required <code>coefficient_rasters</code> <code>Dict[int, str]</code> <p>Mapping from day-of-year (int) to GRASS raster name containing the normalized coefficient (0-1) for that day.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <code>output_prefix</code> <code>str</code> <p>Prefix to use when naming the adjusted rasters.</p> <code>'wrf_adjusted'</code> <p>Returns:</p> Type Description <code>Dict[int, str]</code> <p>Mapping from day-of-year to the created adjusted raster names.</p> Source code in <code>src/utils/wrf.py</code> <pre><code>def calculate_wrf_adjusted_per_day(\n    wrf_day_rasters: Dict[int, str],\n    coefficient_rasters: Dict[int, str],\n    grass_module: Any,\n    output_prefix: str = \"wrf_adjusted\",\n) -&gt; Dict[int, str]:\n    \"\"\"Multiply per-day WRF rasters by corresponding coefficient rasters.\n\n    This creates a new GRASS raster for each day named \"&lt;output_prefix&gt;_day{doy}\".\n\n    Args:\n        wrf_day_rasters: Mapping from day-of-year (int) to GRASS raster name\n            containing that day's WRF data.\n        coefficient_rasters: Mapping from day-of-year (int) to GRASS raster\n            name containing the normalized coefficient (0-1) for that day.\n        grass_module: The GRASS Python scripting Module class.\n        output_prefix: Prefix to use when naming the adjusted rasters.\n\n    Returns:\n        Mapping from day-of-year to the created adjusted raster names.\n    \"\"\"\n    adjusted_rasters: Dict[int, str] = {}\n\n    for day, wrf_raster in wrf_day_rasters.items():\n        # If coefficients are missing for a day, skip with a warning\n        if day not in coefficient_rasters:\n            print(f\"\u26a0\ufe0f Warning: No coefficient raster for day {day}, skipping\")\n            continue\n\n        coeff_raster = coefficient_rasters[day]\n        output_name = f\"{output_prefix}_day{day}\"\n\n        # Use r.mapcalc to multiply rasters in GRASS\n        mapcalc_expr = f\"{output_name} = {wrf_raster} * {coeff_raster}\"\n        grass_module(\n            \"r.mapcalc\",\n            expression=mapcalc_expr,\n            overwrite=True,\n        ).run()\n\n        adjusted_rasters[day] = output_name\n\n    return adjusted_rasters\n</code></pre>"},{"location":"developer/reference/#utils.wrf.calculate_wrf_on_buildings","title":"<code>calculate_wrf_on_buildings(wrf_summed_raster, building_vector, output_name, grass_module)</code>","text":"<p>Apply a building mask and create a building-only WRF raster.</p> <p>Parameters:</p> Name Type Description Default <code>wrf_summed_raster</code> <code>str</code> <p>Name of the summed WRF raster in GRASS.</p> required <code>building_vector</code> <code>str</code> <p>Name of the building footprints vector in GRASS.</p> required <code>output_name</code> <code>str</code> <p>Name to create for the building-only WRF raster.</p> required <code>grass_module</code> <code>Any</code> <p>GRASS Module-like callable.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the created building-only raster (<code>output_name</code>).</p> Source code in <code>src/utils/wrf.py</code> <pre><code>def calculate_wrf_on_buildings(\n    wrf_summed_raster: str, building_vector: str, output_name: str, grass_module: Any\n) -&gt; str:\n    \"\"\"Apply a building mask and create a building-only WRF raster.\n\n    Args:\n        wrf_summed_raster: Name of the summed WRF raster in GRASS.\n        building_vector: Name of the building footprints vector in GRASS.\n        output_name: Name to create for the building-only WRF raster.\n        grass_module: GRASS Module-like callable.\n\n    Returns:\n        The name of the created building-only raster (`output_name`).\n    \"\"\"\n    # Apply building mask to restrict operations to building footprints\n    apply_building_mask(building_vector, grass_module=grass_module)\n\n    r_mapcalc = grass_module(\n        \"r.mapcalc\",\n        expression=f\"{output_name} = {wrf_summed_raster}\",\n        overwrite=True,\n    )\n    r_mapcalc.run()\n\n    remove_masks(grass_module)\n\n    return output_name\n</code></pre>"},{"location":"developer/reference/#utils.wrf.cleanup_wrf_intermediates","title":"<code>cleanup_wrf_intermediates(day_rasters, summed_raster, grass_module)</code>","text":"<p>Remove intermediate WRF rasters from the GRASS mapset.</p> <p>Parameters:</p> Name Type Description Default <code>day_rasters</code> <code>Union[Dict[int, str], Iterable[str]]</code> <p>Dict or iterable containing the names of per-day rasters.</p> required <code>summed_raster</code> <code>Optional[str]</code> <p>Optional name of the summed raster to remove as well.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/utils/wrf.py</code> <pre><code>def cleanup_wrf_intermediates(\n    day_rasters: Union[Dict[int, str], Iterable[str]],\n    summed_raster: Optional[str],\n    grass_module: Any,\n) -&gt; None:\n    \"\"\"Remove intermediate WRF rasters from the GRASS mapset.\n\n    Args:\n        day_rasters: Dict or iterable containing the names of per-day rasters.\n        summed_raster: Optional name of the summed raster to remove as well.\n        grass_module: The GRASS Python scripting Module class.\n\n    Returns:\n        None\n    \"\"\"\n    if isinstance(day_rasters, dict):\n        raster_list = list(day_rasters.values())\n    else:\n        raster_list = list(day_rasters)\n\n    for raster in raster_list:\n        grass_module(\n            \"g.remove\", type=\"raster\", name=raster, flags=\"f\", quiet=True\n        ).run()\n\n    if summed_raster:\n        grass_module(\n            \"g.remove\", type=\"raster\", name=summed_raster, flags=\"f\", quiet=True\n        ).run()\n</code></pre>"},{"location":"developer/reference/#utils.wrf.process_wrf_for_grass","title":"<code>process_wrf_for_grass(nc_file_path, output_prefix, grass_module, source_crs='EPSG:4326', target_crs=None, days=None, clip_to_raster=None, print_diagnostics=False)</code>","text":"<p>Load WRF NetCDF, (optionally) reproject, import per-day rasters into GRASS and sum.</p> <p>Parameters:</p> Name Type Description Default <code>nc_file_path</code> <code>str</code> <p>Path to the WRF NetCDF file.</p> required <code>output_prefix</code> <code>str</code> <p>Prefix to use when naming imported rasters in GRASS.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <code>source_crs</code> <code>str</code> <p>CRS to attach to the raw WRF dataset (default EPSG:4326).</p> <code>'EPSG:4326'</code> <code>target_crs</code> <code>Optional[str]</code> <p>If provided, reproject the dataset to this CRS before import.</p> <code>None</code> <code>days</code> <code>Optional[Iterable[int]]</code> <p>Iterable of day-of-year integers to import. If None, the function imports the full range present in the dataset.</p> <code>None</code> <code>clip_to_raster</code> <code>Optional[str]</code> <p>If provided, set the GRASS region to this raster and clip imported rasters to that region.</p> <code>None</code> <code>print_diagnostics</code> <code>bool</code> <p>If True, call the diagnostics helper to print dataset metadata.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[int, str]</code> <p>A tuple (imported_rasters, summed_raster_name) where <code>imported_rasters</code> is</p> <code>str</code> <p>a dict mapping day-of-year to GRASS raster name and <code>summed_raster_name</code></p> <code>Tuple[Dict[int, str], str]</code> <p>is the name of the combined total raster produced.</p> Source code in <code>src/utils/wrf.py</code> <pre><code>def process_wrf_for_grass(\n    nc_file_path: str,\n    output_prefix: str,\n    grass_module: Any,\n    source_crs: str = \"EPSG:4326\",\n    target_crs: Optional[str] = None,\n    days: Optional[Iterable[int]] = None,\n    clip_to_raster: Optional[str] = None,\n    print_diagnostics: bool = False,\n) -&gt; Tuple[Dict[int, str], str]:\n    \"\"\"Load WRF NetCDF, (optionally) reproject, import per-day rasters into GRASS and sum.\n\n    Args:\n        nc_file_path: Path to the WRF NetCDF file.\n        output_prefix: Prefix to use when naming imported rasters in GRASS.\n        grass_module: The GRASS Python scripting Module class.\n        source_crs: CRS to attach to the raw WRF dataset (default EPSG:4326).\n        target_crs: If provided, reproject the dataset to this CRS before import.\n        days: Iterable of day-of-year integers to import. If None, the function\n            imports the full range present in the dataset.\n        clip_to_raster: If provided, set the GRASS region to this raster and\n            clip imported rasters to that region.\n        print_diagnostics: If True, call the diagnostics helper to print dataset\n            metadata.\n\n    Returns:\n        A tuple (imported_rasters, summed_raster_name) where `imported_rasters` is\n        a dict mapping day-of-year to GRASS raster name and `summed_raster_name`\n        is the name of the combined total raster produced.\n    \"\"\"\n    # Optionally print diagnostics\n    if print_diagnostics:\n        from .diagnostics import print_wrf_diagnostics\n\n        wrf_ds = print_wrf_diagnostics(nc_file_path)\n\n        # Ensure expected coordinate names and metadata for subsequent operations\n        wrf_ds = wrf_ds.rename({\"lon\": \"x\", \"lat\": \"y\"})\n        wrf_ds.rio.write_crs(source_crs, inplace=True)\n        wrf_ds.rio.set_spatial_dims(x_dim=\"x\", y_dim=\"y\", inplace=True)\n    else:\n        wrf_ds = _load_wrf_with_crs(nc_file_path, crs=source_crs)\n\n    # Reproject to the target CRS if requested\n    if target_crs:\n        wrf_ds = wrf_ds.rio.reproject(target_crs)\n\n    # If days is not provided infer the full range from dataset dayofyear values\n    if days is None:\n        # Convert to a sorted list of unique dayofyear integers present in dataset\n        days = sorted(int(d) for d in xr.DataArray(wrf_ds[\"dayofyear\"]).values)\n\n    imported_rasters = _import_wrf_to_grass(\n        wrf_ds, output_prefix, grass_module, days, clip_to_raster\n    )\n\n    # Sum imported daily rasters into a single total raster\n    summed_raster_name = f\"{output_prefix}_total\"\n    summed_raster = _sum_wrf_rasters(imported_rasters, summed_raster_name, grass_module)\n\n    return imported_rasters, summed_raster\n</code></pre>"},{"location":"developer/reference/#utils.wrf.sum_adjusted_rasters","title":"<code>sum_adjusted_rasters(adjusted_rasters, output_name, grass_module, cleanup=True)</code>","text":"<p>Sum a collection of per-day adjusted WRF rasters into a single raster.</p> <p>This uses <code>r.series</code> (method=sum) when provided a list of raster names; if a dict of day-&gt;raster is supplied the dict values are used.</p> <p>Parameters:</p> Name Type Description Default <code>adjusted_rasters</code> <code>Union[Dict[int, str], Iterable[str]]</code> <p>Mapping or iterable of raster names to sum.</p> required <code>output_name</code> <code>str</code> <p>Name for the summed raster in GRASS.</p> required <code>grass_module</code> <code>Any</code> <p>The GRASS Python scripting Module class.</p> required <code>cleanup</code> <code>bool</code> <p>If True, remove the input adjusted rasters from the mapset after the sum is created.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The name of the summed raster (<code>output_name</code>).</p> Source code in <code>src/utils/wrf.py</code> <pre><code>def sum_adjusted_rasters(\n    adjusted_rasters: Union[Dict[int, str], Iterable[str]],\n    output_name: str,\n    grass_module: Any,\n    cleanup: bool = True,\n) -&gt; str:\n    \"\"\"Sum a collection of per-day adjusted WRF rasters into a single raster.\n\n    This uses `r.series` (method=sum) when provided a list of raster names; if\n    a dict of day-&gt;raster is supplied the dict values are used.\n\n    Args:\n        adjusted_rasters: Mapping or iterable of raster names to sum.\n        output_name: Name for the summed raster in GRASS.\n        grass_module: The GRASS Python scripting Module class.\n        cleanup: If True, remove the input adjusted rasters from the mapset\n            after the sum is created.\n\n    Returns:\n        The name of the summed raster (`output_name`).\n    \"\"\"\n    if isinstance(adjusted_rasters, dict):\n        raster_list = list(adjusted_rasters.values())\n    else:\n        raster_list = list(adjusted_rasters)\n\n    grass_module(\n        \"r.series\",\n        input=\",\".join(raster_list),\n        output=output_name,\n        method=\"sum\",\n        overwrite=True,\n    ).run()\n\n    # Optionally remove intermediate rasters to keep the GRASS mapset tidy\n    if cleanup and raster_list:\n        grass_module(\n            \"g.remove\",\n            type=\"raster\",\n            name=\",\".join(raster_list),\n            flags=\"f\",\n        ).run()\n\n    return output_name\n</code></pre>"},{"location":"developer/reference/#environment-grass-setup","title":"Environment &amp; GRASS Setup","text":"<p>GRASS GIS environment setup helper.</p> <p>This module provides a single convenience function, <code>setup_grass</code>, which enables the programmatic usage of GRASS GIS.</p>"},{"location":"developer/reference/#utils.grass_utils.setup_grass","title":"<code>setup_grass(gisbase, grassdata_dir='grassdata', location='solar_estimates', mapset='PERMANENT')</code>","text":"<p>Prepare the GRASS Python bindings and initialize a session.</p> This function <ul> <li>uses GISBASE to locate the GRASS installation</li> <li>appends relevant GRASS directories to PATH,</li> <li>ensures <code>grassdata_dir</code> exists and creates it if missing</li> <li>calls <code>gscript.setup.init(grassdata_dir, location, mapset)</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>gisbase</code> <code>str</code> <p>Filesystem path to the GRASS installation root (contains <code>bin/</code>, <code>scripts/</code>, and <code>etc/</code> directories).</p> required <code>grassdata_dir</code> <code>str</code> <p>Directory to host GRASS locations (created if missing).</p> <code>'grassdata'</code> <code>location</code> <code>str</code> <p>Name of the location under <code>grassdata_dir</code> to use or create.</p> <code>'solar_estimates'</code> <code>mapset</code> <code>str</code> <p>GRASS mapset to initialize inside the Location.</p> <code>'PERMANENT'</code> <p>Returns:</p> Type Description <code>object</code> <p>A tuple <code>(gscript, Module)</code> where <code>gscript</code> is the imported <code>grass.script</code></p> <code>type</code> <p>module and <code>Module</code> is the class from <code>grass.pygrass.modules</code>. These are</p> <code>Tuple[object, type]</code> <p>used for running GRASS's modules.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If GRASS Python modules cannot be imported after modifying <code>sys.path</code>.</p> <code>CalledProcessError</code> <p>If the attempt to create a new GRASS Location fails.</p> Source code in <code>src/utils/grass_utils.py</code> <pre><code>def setup_grass(\n    gisbase: str,\n    grassdata_dir: str = \"grassdata\",\n    location: str = \"solar_estimates\",\n    mapset: str = \"PERMANENT\",\n) -&gt; Tuple[object, type]:\n    \"\"\"Prepare the GRASS Python bindings and initialize a session.\n\n    This function:\n      - uses GISBASE to locate the GRASS installation\n      - appends relevant GRASS directories to PATH,\n      - ensures `grassdata_dir` exists and creates it if missing\n      - calls `gscript.setup.init(grassdata_dir, location, mapset)`\n\n    Args:\n        gisbase: Filesystem path to the GRASS installation root (contains `bin/`, `scripts/`,\n            and `etc/` directories).\n        grassdata_dir: Directory to host GRASS locations (created if missing).\n        location: Name of the location under `grassdata_dir` to use or create.\n        mapset: GRASS mapset to initialize inside the Location.\n\n    Returns:\n        A tuple `(gscript, Module)` where `gscript` is the imported `grass.script`\n        module and `Module` is the class from `grass.pygrass.modules`. These are\n        used for running GRASS's modules.\n\n    Raises:\n        ImportError: If GRASS Python modules cannot be imported after modifying `sys.path`.\n        subprocess.CalledProcessError: If the attempt to create a new GRASS Location fails.\n    \"\"\"\n    # Set the GISBASE environment variable and locate GRASS dirs\n    os.environ[\"GISBASE\"] = gisbase\n    grass_bin = os.path.join(os.environ[\"GISBASE\"], \"bin\")\n    grass_scripts = os.path.join(os.environ[\"GISBASE\"], \"scripts\")\n    grass_python = os.path.join(os.environ[\"GISBASE\"], \"etc\", \"python\")\n\n    # Ensure GRASS executables and scripts can be found by subprocesses\n    os.environ[\"PATH\"] += os.pathsep + grass_bin + os.pathsep + grass_scripts\n\n    # Ensure Python can import GRASS packages\n    sys.path.insert(0, grass_python)\n\n    # Import GRASS scripting interfaces\n    try:\n        import grass.script as gscript  # type: ignore\n        from grass.pygrass.modules import Module  # type: ignore\n    except ImportError as e:\n        # Provide diagnostic context before re-raising\n        print(\n            \"\ud83d\udeab Error importing GRASS Python modules. Check if dependencies are installed correctly.\"\n        )\n        print(f\"GISBASE used: {gisbase}\")\n        raise\n\n    # Ensure the grassdata directory exists\n    os.makedirs(grassdata_dir, exist_ok=True)\n\n    # Create the requested Location if it does not exist.\n    # TODO: take EPSG as argument?\n    location_path = os.path.join(grassdata_dir, location)\n    if not os.path.exists(location_path):\n        cmd = [\"grass\", \"--text\", \"-c\", \"EPSG:2193\", location_path]\n        print(f\"DEBUG: Attempting to create GRASS Location: {' '.join(cmd)}\")\n\n        proc = subprocess.Popen(\n            cmd,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n        )\n        # Provide an \"exit\" in case interactive prompts appear\n        out, err = proc.communicate(\"exit\\n\")\n\n        if proc.returncode != 0:\n            # Print diagnostics and raise an error that includes output\n            print(\"\\n!!! GRASS LOCATION CREATION FAILED !!!\")\n            print(f\"Command: {' '.join(cmd)}\")\n            print(f\"Return Code: {proc.returncode}\")\n            print(\"\\n--- GRASS STDOUT ---\")\n            print(out)\n            print(\"\\n--- GRASS STDERR ---\")\n            print(err)\n            print(\"--------------------------------------\\n\")\n\n            raise subprocess.CalledProcessError(\n                proc.returncode,\n                cmd,\n                output=out,\n                stderr=err,\n            )\n\n    # Initialize a GRASS session in this process\n    gscript.setup.init(grassdata_dir, location, mapset)\n\n    # Return the scripting interface and Module class for running GRASS modules\n    return gscript, Module\n</code></pre>"},{"location":"developer/reference/#diagnostics","title":"Diagnostics","text":""},{"location":"developer/reference/#utils.diagnostics.print_wrf_diagnostics","title":"<code>print_wrf_diagnostics(nc_file_path)</code>","text":"<p>Load a WRF NetCDF file and print comprehensive diagnostic information.</p> Source code in <code>src/utils/diagnostics.py</code> <pre><code>def print_wrf_diagnostics(nc_file_path):\n    \"\"\"Load a WRF NetCDF file and print comprehensive diagnostic information.\"\"\"\n\n    print(\"=\" * 80)\n    print(\"WRF NetCDF FILE DIAGNOSTICS\")\n    print(\"=\" * 80)\n    print(f\"\\nFile: {nc_file_path}\\n\")\n\n    ds = xr.open_dataset(nc_file_path, engine=\"h5netcdf\")\n\n    print(\"-\" * 80)\n    print(\"DATASET OVERVIEW\")\n    print(\"-\" * 80)\n    print(ds)\n    print()\n\n    print(\"-\" * 80)\n    print(\"DATASET INFO\")\n    print(\"-\" * 80)\n    print(ds.info())\n    print()\n\n    print(\"-\" * 80)\n    print(\"DIMENSIONS\")\n    print(\"-\" * 80)\n    for dim_name, dim_size in ds.sizes.items():\n        print(f\"  {dim_name}: {dim_size}\")\n    print()\n\n    print(\"-\" * 80)\n    print(\"COORDINATES\")\n    print(\"-\" * 80)\n    for coord_name, coord_data in ds.coords.items():\n        print(f\"\\n  {coord_name}:\")\n        print(f\"    Shape: {coord_data.shape}\")\n        print(f\"    Dtype: {coord_data.dtype}\")\n        print(f\"    Min: {coord_data.min().values}, Max: {coord_data.max().values}\")\n        if coord_data.attrs:\n            print(f\"    Attributes: {dict(coord_data.attrs)}\")\n    print()\n\n    print(\"-\" * 80)\n    print(\"DATA VARIABLES\")\n    print(\"-\" * 80)\n    for var_name, var_data in ds.data_vars.items():\n        print(f\"\\n  {var_name}:\")\n        print(f\"    Shape: {var_data.shape}\")\n        print(f\"    Dtype: {var_data.dtype}\")\n        print(f\"    Dimensions: {var_data.dims}\")\n        try:\n            print(f\"    Min: {var_data.min().values}, Max: {var_data.max().values}\")\n            print(f\"    Mean: {var_data.mean().values}\")\n        except Exception as e:\n            print(f\"    (Could not compute statistics: {e})\")\n        if var_data.attrs:\n            print(\"    Attributes:\")\n            for attr_key, attr_val in var_data.attrs.items():\n                print(f\"      {attr_key}: {attr_val}\")\n    print()\n\n    print(\"-\" * 80)\n    print(\"GLOBAL ATTRIBUTES\")\n    print(\"-\" * 80)\n    if ds.attrs:\n        for attr_key, attr_val in ds.attrs.items():\n            print(f\"  {attr_key}: {attr_val}\")\n    else:\n        print(\"  No global attributes found\")\n    print()\n\n    print(\"-\" * 80)\n    print(\"COORDINATE REFERENCE SYSTEM INFO\")\n    print(\"-\" * 80)\n    try:\n        if hasattr(ds, \"rio\"):\n            print(f\"  CRS: {ds.rio.crs}\")\n            print(f\"  Transform: {ds.rio.transform()}\")\n            print(f\"  Bounds: {ds.rio.bounds()}\")\n        else:\n            print(\"  No rioxarray spatial metadata found\")\n    except Exception as e:\n        print(f\"  Could not retrieve CRS info: {e}\")\n    print()\n\n    print(\"=\" * 80)\n    print(\"END OF DIAGNOSTICS\")\n    print(\"=\" * 80)\n    print()\n\n    return ds\n</code></pre>"},{"location":"developer/reference/#linke-turbidity","title":"Linke Turbidity","text":""},{"location":"developer/website-guide/","title":"Website Maintenance Guide","text":"<p>This guide describes how the website infrastructure is setup.</p> <p>Last updated: Jan 2026</p> <p>Target site: https://rewiring-nz.github.io/solar-estimates/</p>"},{"location":"developer/website-guide/#publish-pipeline","title":"Publish pipeline","text":"<p><pre><code>graph TD\n    subgraph Local Development\n        A[docs/*.md] --Guides / Howtos --&gt; D{ }\n        B[src/*.py Docstrings] --&gt; Y{ }\n        X[reference.md] --&gt; Y --API Reference--&gt; D\n        C[mkdocs.yml] -- Navigation / Style --&gt; D\n        D --docker compose up docs--&gt; K\n    end\n    K(http://localhost:8080) ~~~ E\n\n    subgraph Github Pages\n        E[.github/workflows/deploy.yml] --&gt; F\n        D -- git push main --&gt; F{GitHub\n          Actions}\n        F --&gt; G(rewiring-nz.github.io/solar-estimates)\n    end</code></pre> Diagram: Doc toolchain workflow</p>"},{"location":"developer/website-guide/#documentation-sources","title":"Documentation Sources","text":"Source Description docs/*.md Standard documentation is in markdown. src/*.py The \"API Reference\" section is automatically extracted from Python docstrings in mkdocs format. docs/developer/reference.md New python files need to be added in order to extract docs-as-code. mkdocs.yml Navigation and Style: New files need to be added to the nav section of this config."},{"location":"developer/website-guide/#local-preview","title":"Local Preview","text":"<p>Before publishing, you can preview with: <pre><code># Change to project's root directory\n#\n# Start local web server\ndocker compose up docs\n\n# View in a browser at: http://localhost:8000\n</code></pre></p>"},{"location":"developer/website-guide/#publish-workflow","title":"Publish Workflow","text":"<ol> <li>The Trigger: A <code>git push</code> to <code>main</code> triggers <code>/.github/workflows/deploy.yml</code>.  </li> <li>The Build: Actions runs mkdocs gh-deploy, pushing HTML to the <code>gh-pages</code> branch.  </li> <li>The Hosting: GitHub Pages watches gh-pages and refreshes the live site at https://rewiring-nz.github.io/solar-estimates/</li> </ol>"},{"location":"developer/website-guide/#technology-stack","title":"Technology Stack","text":"<ul> <li>MkDocs: The static site generator that converts Markdown to HTML.  </li> <li>Material for MkDocs: The theme providing the UI/UX and search.  </li> <li>mkdocstrings: A plugin that inspects Python source code to generate the API reference.  </li> <li>GitHub Actions: The CI/CD engine that automates the build process.  </li> <li>GitHub Pages: The hosting service that serves the final files.</li> </ul>"},{"location":"user/","title":"User Guide","text":"<p>This User Guide is for tech savvy users, looking to create custom maps by running our python scripts from the command line.</p>"},{"location":"user/how-to-use-your-own-data/","title":"How-to: Use Your Own Source Data","text":"<p>This guide explains how to source and use your own data for our solar pipeline generation script, running within a Docker container.</p> <p>Last updated: Jan 2026</p> <p>Warning</p> <p>Our pipeline script is CPU intensive. You are likely to run out of memory, or take a very long time to run. Best to start with small datasets before getting larger.</p>"},{"location":"user/how-to-use-your-own-data/#1-where-to-get-source-data","title":"1. Where to Get Source Data","text":"<p>The pipeline script requires two primary inputs: Digital Surface Models (DSM) and Building Outlines.</p>"},{"location":"user/how-to-use-your-own-data/#11-digital-surface-models-dsm","title":"1.1 Digital Surface Models (DSM)","text":"<p>For accurate solar modeling (including roof pitch and shading from chimneys or trees), you need a 1m resolution DSM.</p> <ul> <li>Source: Search for the latest at: LINZ Data Service - New Zealand LiDAR 1m DSM</li> <li>Format: Download as GeoTIFF files.</li> <li>Region: Select a region you are interested in. You might experience download size limits.</li> <li>Coordinate System: Ensure your data is in EPSG:2193 (NZGD2000 / New Zealand Transverse Mercator 2000).</li> </ul> <p>Tip</p> <p>Digital Surface Models (DSM) include building rooftops and tree tops. Digital Elevation Models (DEM) are not suitable for our analysis as they represent bare ground elevation.</p>"},{"location":"user/how-to-use-your-own-data/#12-building-outlines","title":"1.2 Building Outlines","text":"<ul> <li>Source: LINZ Data Service - All Building Outlines</li> <li>Format: Download as a ShapeFile.</li> <li>Coordinate System: Ensure your data is in EPSG:2193 (NZGD2000 / New Zealand Transverse Mercator 2000).</li> </ul> <p>Tip</p> <p>The Geopackage format is faster for spatial analysis than the legacy <code>shapefile</code> format. It is a standards based Spatialite database in a file, which extends the SQLite format.</p> <p>Note</p> <p>We've observed:</p> <ul> <li>NZ Building Outlines, Dec 2025 provides an authoritative dataset, but is missing some buildings.</li> <li>NZ Building Outlines (All Sources), Dec 2025 covers more buildings, but also has duplicates.</li> </ul>"},{"location":"user/how-to-use-your-own-data/#2-organising-your-data-folder","title":"2. Organising Your Data Folder","text":"<p>To make your data accessible to the pipeline.py script in your Docker container, put it in the appropriate sub-folders within <code>src/data/inputs</code>. There are folders for different data types (e.g. buliding outlines, DSMs, weather). You should create a new sub-folder for data on new areas, named something like <code>district_YourDistrictHere</code>, <code>suburb_YourSuburbHere</code>, <code>region_*</code>, <code>electorate_*</code>, <code>ta_*</code> (territorial authority), or <code>nationwide</code>, to make it really clear exactly what is included in the data and what is not. Use <code>snake_case</code>, not <code>kebab-case</code>, for consistency (kebab case is reserved for other things in parts of the pipeline).</p> <p>The pipeline will calculate for the areas in the intersect of the building outlines and the DSMs provided. So they don't have to be exactly the same, e.g. you might have a DSM of just the suburb Shotover Country, but run it with building outlines for all of the Queenstown Lakes district.</p> <pre><code>solar-estimates/\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 data/\n        \u2514\u2500\u2500 inputs/\n            \u2514\u2500\u2500 building_outlines/\n                \u251c\u2500\u2500 district_MyCoolDistrict/\n                    \u251c\u2500\u2500 nz-building-outlines.cpg\n                    \u251c\u2500\u2500 nz-building-outlines.dbf\n                    \u251c\u2500\u2500 nz-building-outlines.prj\n                    \u251c\u2500\u2500 nz-building-outlines.shp\n                    \u251c\u2500\u2500 nz-building-outlines.shx\n                    \u251c\u2500\u2500 nz-building-outlines.txt\n                    \u2514\u2500\u2500 nz-building-outlines.xml\n            \u2514\u2500\u2500 DEM/\n            \u2514\u2500\u2500 DSM/\n                \u2514\u2500\u2500 district_MyCoolDistrict/\n                    \u251c\u2500\u2500 dsm_tile_1.tif\n                    \u251c\u2500\u2500 dsm_tile_1.tif.aux.xml\n                    \u251c\u2500\u2500 dsm_tile_2.tif\n                    \u2514\u2500\u2500 dsm_tile_2.tif.aux.xml\n                    ...\n            \u2514\u2500\u2500 weather/\n                \u2514\u2500\u2500 nationwide/\n</code></pre>"},{"location":"user/how-to-use-your-own-data/#3-create-a-config-file","title":"3. Create a config file","text":"<p>Since the pipeline has a lot of long input arguments, we have config environment files where you can organise these. See the <code>config/</code> folder for examples and create a new one that points to your newly organised custom data.</p> <p>The pipeline has many input arguments that you can try. See <code>src/README.md</code> for an explanation of each of the arguments.</p>"},{"location":"user/how-to-use-your-own-data/#4-run-the-pipeline-with-your-custom-data","title":"4. Run the pipeline with your custom data","text":"<p>To run the pipeline script with your own data by pointing the docker container towards a particular environment file, like this example:</p> <pre><code>docker compose --env-file configs/suburb_ShotoverCountry.env up pipeline\n</code></pre> <p>The output will appear in the <code>src/data/outputs/OUTPUT_AREA_NAME</code> directory as defined in your config file, like this:</p> <pre><code>solar-estimates/\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 data/\n        \u2514\u2500\u2500 outputs/\n            \u2514\u2500\u2500 OUTPUT_AREA_NAME/\n                \u251c\u2500\u2500 OUTPUT_AREA_NAME_building_stats.csv\n                \u251c\u2500\u2500 OUTPUT_AREA_NAME_building_stats.gpkg\n                \u2514\u2500\u2500 OUTPUT_AREA_NAME_merged.vrt\n</code></pre>"},{"location":"user/pipeline-quickstart/","title":"Quickstart: Run pipeline script","text":"<p>This quickstart describes how you can install and run our pipeline script to create your first map layers, based on a default dataset and default parameters.</p>"},{"location":"user/pipeline-quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Command Line: Familiarity with running commands from a terminal.  </li> <li>Docker: Familiarity with Docker. We use it to ensure the environment is consistent.  </li> <li>Git (Optional): Understanding <code>git</code> is helpful for managing updates. Refer to GitHub's Git Guide for a quick overview.  </li> <li>Admin Rights: You will likely need administrator privileges to install Docker.</li> </ul>"},{"location":"user/pipeline-quickstart/#1-download-the-solar-estimates-code","title":"1: Download the Solar-Estimates Code","text":"<p>You can either download the code as a simple zip file or use <code>git</code> to clone the repository.</p>"},{"location":"user/pipeline-quickstart/#option-1a-download-and-unzip-simplest","title":"Option 1A: Download and Unzip (Simplest)","text":"<pre><code># Move to your home directory\ncd ~\n\n# Download and unzip the latest source code \nwget https://github.com/rewiring-nz/solar-estimates/archive/refs/heads/main.zip \nunzip main.zip\nmv ~/solar-estimates-main/ ~/solar-estimates/\ncd ~/solar-estimates/\n</code></pre>"},{"location":"user/pipeline-quickstart/#option-1b-clone-with-git-recommended-for-developers","title":"Option 1B: Clone with Git (Recommended for Developers)","text":"<pre><code># Move to your home directory\ncd ~\n\n# clone repository\n`git clone https://github.com/rewiring-nz/solar-estimates.git\ncd solar-estimates/\n</code></pre> <p>Tip</p> <p>You can find these download details from the github source page: https://github.com/rewiring-nz/solar-estimates.</p>"},{"location":"user/pipeline-quickstart/#2-install-docker","title":"2: Install Docker","text":"<p>If you haven\u2019t already installed Docker, follow the instructions for your operating system:</p>"},{"location":"user/pipeline-quickstart/#option-2a-windows-or-mac","title":"Option 2A: Windows or Mac:","text":"<p>Follow the official Docker Desktop installation guide. Then start docker by opening the application. In your taskbar you should see a little whale icon. When clicked, it should say <code>Docker Desktop is running</code>.</p>"},{"location":"user/pipeline-quickstart/#option-2b-ubuntu-or-debian-linux","title":"Option 2B: Ubuntu or Debian Linux:","text":"<p>You can use our setup script:</p> <pre><code># Navigate to the scripts directory and run the installer \ncd scripts\nsudo ./setup-docker.sh\n</code></pre>"},{"location":"user/pipeline-quickstart/#3-run-the-pipeline","title":"3: Run the Pipeline","text":"<p>With Docker ready, you can now launch the processing pipeline. This process downloads required images and runs the analysis, which may take several minutes.</p> <p><pre><code># Ensure you are in the project root directory (i.e. go back up one level if you were in scripts/ or src/)\n\ndocker compose --env-file configs/shotover.env up pipeline\n</code></pre> You will see logs in your terminal as the <code>pipeline.sh</code> script executes.</p> <p>Once finished, observe that you have created the following files in the <code>solar-estimates/src/data/outputs/OUTPUT_AREA_NAME/</code> directory:</p> File Layer Type <code>suburb_ShotoverCountry_building_stats.gpkg</code> GeoPackage: A spatial database containing a layer of building polygons and their solar attributes. <code>suburb_ShotoverCountry_merged.vrt</code> Virtual Raster: A wrapper to multiple solar irradiation tiles. <code>suburb_ShotoverCountry_building_stats.csv</code> Tabular Data: A spreadsheet of building solar attributes."},{"location":"user/pipeline-quickstart/#4-stop-and-clean-up","title":"4: Stop and Clean Up","text":"<p>When you are finished or want to stop the process, use the following command to shut down the Docker container safely:</p> <pre><code># Again, run this from your root directory\ndocker compose down\n</code></pre>"},{"location":"user/pipeline-quickstart/#next-steps","title":"Next steps","text":"<ol> <li>View Map Layers: Why don't you use QGIS to view the map layers you just created, by following our QGIS Quickstart.</li> </ol>"},{"location":"user/qgis-quickstart/","title":"Quickstart: Visualising Results in QGIS","text":"<p>This quickstart describes how to view and query our geographic map layers using QGIS.</p>"},{"location":"user/qgis-quickstart/#what-is-qgis","title":"What is QGIS?","text":"<p>We love QGIS. It is an intuitive, powerful, free, and open-source desktop GIS application, used for visualising geospatial maps, running spatial queries, and creating maps to share with others.</p>"},{"location":"user/qgis-quickstart/#1-setup-environment-and-first-map","title":"1. Setup environment and first map","text":"<p>If you haven't done so already, follow our Pipeline Quickstart to setup your environment and create your first map layers.</p>"},{"location":"user/qgis-quickstart/#2-install-qgis","title":"2. Install QGIS","text":"<p>Download and install QGIS, per instructions at the QGIS Download page.</p>"},{"location":"user/qgis-quickstart/#3-load-our-map-layers","title":"3. Load Our Map Layers","text":"<ol> <li>Run QGIS on your desktop.</li> <li>In the QGIS Browser pane, navigate to the <code>solar-estimates/src/</code> directory.</li> <li>Double-click on the <code>suburb_ShotoverCountry_building_stats.gpkg</code> file to show it's layers.</li> <li>Right-click on the <code>building_stats</code> layer and select <code>Add Layer to Project</code>.<ol> <li>See the building outlines getting rendered in the Map pane.</li> <li>See the buildings title get add to the Layers pane.</li> </ol> </li> </ol>"},{"location":"user/qgis-quickstart/#4-add-a-base-map-openstreetmap","title":"4. Add a Base Map (OpenStreetMap)","text":"<p>To see where these buildings are located in the real world, you can add OpenStreetMap as a background layer.</p> <ol> <li>In the Browser panel, scroll down to <code>XYZ Tiles</code>.</li> <li>Double-click on <code>XYZ Tiles</code> to expand it, and see the layers it supports.</li> <li>Right-click <code>OpenStreetMap</code> and select <code>Add Layer to Project</code>.</li> <li>Move to Background: In the Layers panel, click and drag the <code>OpenStreetMap</code> layer so it sits under your building stats layer.</li> </ol>"},{"location":"user/qgis-quickstart/#5-query-building-data","title":"5. Query Building Data","text":"<p>We can query the attributes associated with each building.</p> <ol> <li>Select the Identify Features tool from the top toolbar (the icon with a small \"i\" and a white arrow pointer).</li> <li>Click on a building polygon in the map pane.</li> <li>An Identify Results panel will pop up, showing you all attributes for that building.</li> </ol>"},{"location":"user/qgis-quickstart/#things-to-try","title":"Things to try","text":"<ol> <li>Try adding the <code>shotover_country_merged.vrt</code> layer to your map.</li> </ol>"}]}